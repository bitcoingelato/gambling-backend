<script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
          return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                var firstSheetName = workbook.SheetNames[0];
                var worksheet = workbook.Sheets[firstSheetName];

                // Convert sheet to JSON to filter blank rows
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                // Filter out blank rows (rows where all cells are empty, null, or undefined)
                var filteredData = jsonData.filter(row => row.some(filledCell));

                // Heuristic to find the header row by ignoring rows with fewer filled cells than the next row
                var headerRowIndex = filteredData.findIndex((row, index) =>
                  row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                );
                // Fallback
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                  headerRowIndex = 0;
                }

                // Convert filtered JSON back to CSV
                var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex)); // Create a new sheet from filtered array of arrays
                csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                return csv;
            } catch (e) {
                console.error(e);
                return "";
            }
        }
        return gk_fileData[filename] || "";
        }
        </script><!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bitcoin Gelato Casino</title>
    <style>
        body { font-family: Arial; background: #000; color: #fff; margin: 0; padding: 10px; }
        .container { max-width: 600px; margin: 0 auto; }
        .header { background: #333; padding: 10px; text-align: center; }
        .tabs { margin: 10px 0; text-align: center; }
        .tab { color: #FFC107; text-decoration: none; margin: 0 10px; cursor: pointer; }
        .tab.active { color: #fff; border-bottom: 2px solid #fff; }
        .section { background: #222; padding: 10px; margin-bottom: 10px; }
        .hidden { display: none !important; }
        .modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); display: flex; justify-content: center; align-items: center; z-index: 1000; }
        .modal-content { background: #333; padding: 20px; width: 300px; text-align: center; }
        .modal-tabs { display: flex; margin-bottom: 20px; }
        .modal-tab { flex: 1; padding: 10px; cursor: pointer; color: #FFC107; }
        .modal-tab.active { color: #fff; border-bottom: 2px solid #fff; }
        .modal-content input { width: 100%; padding: 8px; margin: 10px 0; background: #444; color: #fff; border: 1px solid #FFC107; }
        .modal-content button { width: 100%; padding: 10px; background: #FFC107; color: #000; border: none; cursor: pointer; }
        .error { color: #FF0000; font-size: 0.9em; margin-top: 5px; }
        .multiplier { font-size: 1.5em; background: #FFC107; color: #000; padding: 5px; text-align: center; }
        .graph { width: 100%; height: 100px; background: #333; border: 1px solid #FFC107; position: relative; }
        .graph-line { position: absolute; bottom: 0; left: 0; height: 2px; background: #00FF00; transition: width 0.1s linear; }
        .graph-crash { position: absolute; bottom: 0; left: 0; height: 100%; background: rgba(255, 0, 0, 0.5); transition: width 0.1s linear; }
        .bet-controls { text-align: center; margin: 10px 0; }
        .bet-controls input, .bet-controls select { padding: 5px; margin: 5px; background: #444; color: #fff; border: 1px solid #FFC107; }
        .bet-controls button { padding: 5px 10px; margin: 5px; background: #FFC107; color: #000; border: none; cursor: pointer; }
        .bet-controls button:disabled { background: #666; }
        .crash-timer { text-align: center; color: #FFC107; }
        .coinflip-choice { display: flex; justify-content: center; gap: 10px; margin: 10px 0; }
        .coinflip-choice img { width: 50px; height: 50px; cursor: pointer; border: 2px solid transparent; }
        .coinflip-choice img.selected { border-color: #fff; }
        table { width: 100%; border-collapse: collapse; margin-top: 10px; background: #333; }
        th, td { border: 1px solid #FFC107; padding: 5px; text-align: center; }
        th { background: #444; }
        .win { color: #00FF00; }
        .loss { color: #FF0000; }
        .crash-low { color: #FF0000; }
        .crash-high { color: #00FF00; }
        .card-display { display: flex; gap: 10px; justify-content: center; margin: 10px 0; }
        .card { padding: 5px; background: #fff; color: #000; border: 1px solid #FFC107; border-radius: 5px; }
        .verify-details { font-size: 0.8em; color: #FFC107; margin-top: 5px; }
    </style>
</head>
<body>
    <div id="modal" class="modal hidden">
        <div class="modal-content">
            <div class="modal-tabs">
                <div id="loginTab" class="modal-tab active">Login</div>
                <div id="signupTab" class="modal-tab">Sign Up</div>
            </div>
            <div id="loginForm">
                <input type="text" id="loginUsername" placeholder="Username">
                <input type="password" id="loginPassword" placeholder="Password">
                <button id="loginButton">Login</button>
                <p id="loginError" class="error hidden"></p>
            </div>
            <div id="signupForm" class="hidden">
                <input type="text" id="signupUsername" placeholder="Username">
                <input type="email" id="signupEmail" placeholder="Email">
                <input type="password" id="signupPassword" placeholder="Password">
                <input type="password" id="signupConfirmPassword" placeholder="Confirm Password">
                <button id="signupButton">Sign Up</button>
                <p id="signupError" class="error hidden"></p>
            </div>
        </div>
    </div>
    <div id="gameInterface" class="hidden">
        <div class="header">
            <span>Welcome, <span id="headerUsername">Guest</span> | Balance: <span id="balance">0.0100</span> <span id="currencyDisplay">BTC</span> (Fun Mode)</span>
            <select id="currencySelector" onchange="switchCurrency()">
                <option value="BTC">BTC</option>
                <option value="USD">USD</option>
                <option value="BGT">BGT</option>
            </select>
            <button id="logoutButton">Logout</button>
        </div>
        <div class="tabs">
            <a id="tabCrash" class="tab active">Crash</a>
            <a id="tabCoinflip" class="tab">Coinflip</a>
            <a id="tabRoulette" class="tab">Roulette</a>
            <a id="tab3CP" class="tab">3CP</a>
            <a id="tabAccount" class="tab">Account</a>
        </div>
        <div class="container">
            <div id="crashSection" class="section">
                <h2>Crash</h2>
                <div class="multiplier" id="multiplier">1.00x</div>
                <div class="graph">
                    <div class="graph-line" id="graphLine"></div>
                    <div class="graph-crash" id="graphCrash"></div>
                </div>
                <div class="bet-controls">
                    <input type="number" id="crashBetAmount" placeholder="Bet Amount (BTC)" step="0.00000001" min="0.00000001" value="0.0001">
                    <button id="placeBetButton">Place Bet</button>
                    <button id="cancelBetButton" disabled>Cancel Bet</button>
                    <button id="cashoutButton" disabled>Cash Out</button>
                    <button id="verifyFairnessButton">Verify Fairness</button>
                </div>
                <div class="crash-timer" id="crashTimer">Next round in 9s</div>
                <div class="round-history">
                    <h3>Round History</h3>
                    <table id="crashRoundHistoryTable">
                        <tr>
                            <th>Crash Point</th>
                            <th>Round #</th>
                            <th>Bet</th>
                            <th>Verify</th>
                            <th>Time</th>
                        </tr>
                    </table>
                </div>
            </div>
            <div id="coinflipSection" class="section hidden">
                <h2>Coinflip</h2>
                <div class="bet-controls">
                    <input type="number" id="coinflipBetAmount" placeholder="Bet Amount (BTC)" step="0.00000001" min="0.00000001" value="0.0001">
                    <div class="coinflip-choice">
                        <img id="coinHeads" src="https://via.placeholder.com/50" alt="Heads" data-choice="heads">
                        <img id="coinTails" src="https://via.placeholder.com/50" alt="Tails" data-choice="tails">
                    </div>
                    <button id="coinflipButton">Flip Coin</button>
                    <button id="coinflipVerifyButton">Verify Fairness</button>
                </div>
                <div id="coinflipAnimation" style="display: none;">
                    <img id="coinAnimationHeads" src="https://via.placeholder.com/60" alt="Heads">
                    <img id="coinAnimationTails" src="https://via.placeholder.com/60" alt="Tails">
                </div>
                <p><strong>Result:</strong> <span id="coinflipResult">Waiting for flip...</span></p>
                <div class="verify-details" id="coinflipVerifyDetails" style="display: none;">
                    <p><strong>Server Seed:</strong> <span id="coinflipServerSeed">Not revealed</span></p>
                    <p><strong>Client Seed:</strong> <span id="coinflipClientSeed">Not set</span></p>
                </div>
            </div>
            <div id="rouletteSection" class="section hidden">
                <h2>Roulette</h2>
                <div class="bet-controls">
                    <input type="number" id="rouletteBetAmount" placeholder="Bet Amount (BTC)" step="0.00000001" min="0.00000001" value="0.0001">
                    <select id="rouletteBetType">
                        <option value="red">Red</option>
                        <option value="black">Black</option>
                        <option value="green">Green</option>
                    </select>
                    <button id="rouletteSpinButton">Spin</button>
                    <button id="rouletteVerifyButton">Verify Fairness</button>
                </div>
                <p><strong>Result:</strong> <span id="rouletteResult">Waiting for spin...</span></p>
                <div class="verify-details" id="rouletteVerifyDetails" style="display: none;">
                    <p><strong>Server Seed:</strong> <span id="rouletteServerSeed">Not revealed</span></p>
                    <p><strong>Client Seed:</strong> <span id="rouletteClientSeed">Not set</span></p>
                </div>
            </div>
            <div id="threeCardPokerSection" class="section hidden">
                <h2>3 Card Poker (3CP)</h2>
                <div class="bet-controls">
                    <input type="number" id="threeCardPokerBetAmount" placeholder="Ante Bet (BTC)" step="0.00000001" min="0.00000001" value="0.0001">
                    <button id="threeCardPokerAnteButton">Place Ante</button>
                </div>
                <div id="threeCardPokerDecision" class="bet-controls hidden">
                    <p><strong>Your Cards:</strong> <span id="playerCards">Waiting...</span></p>
                    <button id="threeCardPokerPlayButton">Play (Match Ante)</button>
                    <button id="threeCardPokerFoldButton">Fold</button>
                </div>
                <p><strong>Dealer's Cards:</strong> <span id="dealerCards">Hidden</span></p>
                <p><strong>Result:</strong> <span id="threeCardPokerResult">Waiting for bet...</span></p>
                <button id="threeCardPokerVerifyButton" style="display: none;">Verify Fairness</button>
                <div class="verify-details" id="threeCardPokerVerifyDetails" style="display: none;">
                    <p><strong>Server Seed:</strong> <span id="threeCardPokerServerSeed">Not revealed</span></p>
                    <p><strong>Client Seed:</strong> <span id="threeCardPokerClientSeed">Not set</span></p>
                </div>
            </div>
            <div id="accountSection" class="section hidden">
                <h2>Account</h2>
                <div class="bet-controls">
                    <button id="detailsButton">Account Details</button>
                    <button id="historyButton">History</button>
                </div>
                <div id="detailsSubSection">
                    <h3>Account Details</h3>
                    <p>Username: <span id="settingsUsername">Guest</span></p>
                    <p>Balance: <span id="settingsBalance">0.0100</span> <span id="settingsCurrencyDisplay">BTC</span> (Fun Mode)</p>
                    <div>
                        <h4>Change Email</h4>
                        <input id="currentEmail" type="email" placeholder="Current Email" disabled value="user@example.com">
                        <input id="newEmail" type="email" placeholder="New Email">
                        <button id="changeEmailButton">Update Email</button>
                        <p id="emailMessage" class="error hidden"></p>
                    </div>
                    <div>
                        <h4>Change Password</h4>
                        <input id="currentPassword" type="password" placeholder="Current Password">
                        <input id="newPassword" type="password" placeholder="New Password">
                        <input id="confirmNewPassword" type="password" placeholder="Confirm New Password">
                        <button id="changePasswordButton">Update Password</button>
                        <p id="passwordMessage" class="error hidden"></p>
                    </div>
                </div>
                <div id="historySubSection" class="hidden">
                    <h3>Bet History</h3>
                    <table id="settingsHistoryTable">
                        <tr>
                            <th>Game</th>
                            <th>Bet</th>
                            <th>Outcome</th>
                            <th>Multiplier</th>
                            <th>Winnings</th>
                            <th>Timestamp</th>
                        </tr>
                    </table>
                </div>
            </div>
            <div class="section">
                <h3>Bet History</h3>
                <table id="recentBetHistoryTable">
                    <tr>
                        <th>Game</th>
                        <th>Bet</th>
                        <th>Outcome</th>
                        <th>Timestamp</th>
                    </tr>
                </table>
            </div>
        </div>
    </div>
    <script>
        let currentUser = null, balance = { BTC: 0.01, USD: 0, BGT: 0 }, crashGameState = 'waiting', currentMultiplier = 1.00,
            crashInterval = null, crashServerSeed = '', crashClientSeed = '', coinflipServerSeed = '', coinflipClientSeed = '',
            rouletteServerSeed = '', rouletteClientSeed = '', threeCardPokerServerSeed = '', threeCardPokerClientSeed = '',
            crashBetAmount = 0, coinflipBetAmount = 0, rouletteBetAmount = 0, threeCardPokerAnteBet = 0, threeCardPokerPlayBet = 0,
            betHistory = [], coinflipChoice = null, rouletteBetType = 'red', threeCardPokerState = 'waiting', playerHand = [], dealerHand = [],
            crashSeedTimestamp = 0, coinflipSeedTimestamp = 0, rouletteSeedTimestamp = 0, threeCardPokerSeedTimestamp = 0,
            currentCurrency = 'BTC', crashPoint = 0, countdownTimer = null, crashRoundLog = [], totalRounds = 0;

        document.addEventListener('DOMContentLoaded', () => {
            localStorage.getItem('crashRoundLog') || localStorage.setItem('crashRoundLog', '[]');
            localStorage.getItem('totalRounds') || localStorage.setItem('totalRounds', '0');
            localStorage.getItem('users') || localStorage.setItem('users', '[]');
            crashRoundLog = JSON.parse(localStorage.getItem('crashRoundLog'));
            totalRounds = parseInt(localStorage.getItem('totalRounds')) || 0;

            const sessionToken = localStorage.getItem('sessionToken'), username = localStorage.getItem('currentUsername'),
                users = JSON.parse(localStorage.getItem('users'));
            if (sessionToken && username && Array.isArray(users)) {
                currentUser = users.find(u => u.username === username);
                if (currentUser) {
                    balance.BTC = parseFloat(localStorage.getItem(`balance_${username}_BTC`)) || 0.01;
                    balance.USD = parseFloat(localStorage.getItem(`balance_${username}_USD`)) || 200;
                    balance.BGT = parseFloat(localStorage.getItem(`balance_${username}_BGT`)) || 0;
                    crashClientSeed = localStorage.getItem(`crashClientSeed_${username}`) || '';
                    coinflipClientSeed = localStorage.getItem(`coinflipClientSeed_${username}`) || '';
                    rouletteClientSeed = localStorage.getItem(`rouletteClientSeed_${username}`) || '';
                    threeCardPokerClientSeed = localStorage.getItem(`threeCardPokerClientSeed_${username}`) || '';
                    crashSeedTimestamp = parseInt(localStorage.getItem(`crashSeedTimestamp_${username}`) || 0);
                    coinflipSeedTimestamp = parseInt(localStorage.getItem(`coinflipSeedTimestamp_${username}`) || 0);
                    rouletteSeedTimestamp = parseInt(localStorage.getItem(`rouletteSeedTimestamp_${username}`) || 0);
                    threeCardPokerSeedTimestamp = parseInt(localStorage.getItem(`threeCardPokerSeedTimestamp_${username}`) || 0);
                    betHistory = JSON.parse(localStorage.getItem(`betHistory_${username}`) || '[]');
                    if (!Array.isArray(betHistory)) betHistory = [];
                    const now = Date.now();
                    if (!crashClientSeed || now - crashSeedTimestamp > 3600000) {
                        crashClientSeed = generateSeed();
                        crashSeedTimestamp = now;
                        localStorage.setItem(`crashClientSeed_${username}`, crashClientSeed);
                        localStorage.setItem(`crashSeedTimestamp_${username}`, crashSeedTimestamp.toString());
                    }
                    if (!coinflipClientSeed || now - coinflipSeedTimestamp > 3600000) {
                        coinflipClientSeed = generateSeed();
                        coinflipSeedTimestamp = now;
                        localStorage.setItem(`coinflipClientSeed_${username}`, coinflipClientSeed);
                        localStorage.setItem(`coinflipSeedTimestamp_${username}`, coinflipSeedTimestamp.toString());
                    }
                    if (!rouletteClientSeed || now - rouletteSeedTimestamp > 3600000) {
                        rouletteClientSeed = generateSeed();
                        rouletteSeedTimestamp = now;
                        localStorage.setItem(`rouletteClientSeed_${username}`, rouletteClientSeed);
                        localStorage.setItem(`rouletteSeedTimestamp_${username}`, rouletteSeedTimestamp.toString());
                    }
                    if (!threeCardPokerClientSeed || now - threeCardPokerSeedTimestamp > 3600000) {
                        threeCardPokerClientSeed = generateSeed();
                        threeCardPokerSeedTimestamp = now;
                        localStorage.setItem(`threeCardPokerClientSeed_${username}`, threeCardPokerClientSeed);
                        localStorage.setItem(`threeCardPokerSeedTimestamp_${username}`, threeCardPokerSeedTimestamp.toString());
                    }
                    showGameInterface();
                    updateBalance();
                    updateUsername();
                    updateHistory();
                    updateRecentBetHistory();
                    initCrashGame();
                    showSection('crash');
                } else {
                    showLoginModal();
                }
            } else {
                showLoginModal();
            }

            document.getElementById('loginTab').addEventListener('click', () => toggleModalForm('login'));
            document.getElementById('signupTab').addEventListener('click', () => toggleModalForm('signup'));
            document.getElementById('loginButton').addEventListener('click', login);
            document.getElementById('signupButton').addEventListener('click', signup);
            document.getElementById('logoutButton').addEventListener('click', logout);
            ['tabCrash', 'tabCoinflip', 'tabRoulette', 'tab3CP', 'tabAccount'].forEach(tabId => {
                const tabElement = document.getElementById(tabId);
                tabElement.addEventListener('click', () => {
                    const section = tabId.replace('tab', '').toLowerCase();
                    showSection(section);
                    if (section === 'crash' && crashGameState === 'waiting') startCountdownTimer();
                });
            });
            document.getElementById('placeBetButton').addEventListener('click', placeCrashBet);
            document.getElementById('cancelBetButton').addEventListener('click', cancelCrashBet);
            document.getElementById('cashoutButton').addEventListener('click', cashOut);
            document.getElementById('verifyFairnessButton').addEventListener('click', () => verifyCrashFairness(-1));
            document.getElementById('coinflipButton').addEventListener('click', startCoinflip);
            document.getElementById('coinflipVerifyButton').addEventListener('click', verifyCoinflipFairness);
            document.getElementById('rouletteSpinButton').addEventListener('click', spinRoulette);
            document.getElementById('rouletteVerifyButton').addEventListener('click', verifyRouletteFairness);
            document.getElementById('threeCardPokerAnteButton').addEventListener('click', placeThreeCardPokerAnte);
            document.getElementById('threeCardPokerPlayButton').addEventListener('click', playThreeCardPoker);
            document.getElementById('threeCardPokerFoldButton').addEventListener('click', foldThreeCardPoker);
            document.getElementById('threeCardPokerVerifyButton').addEventListener('click', verifyThreeCardPokerFairness);
            document.getElementById('detailsButton').addEventListener('click', () => showSubSection('details'));
            document.getElementById('historyButton').addEventListener('click', () => showSubSection('history'));
            document.getElementById('changeEmailButton').addEventListener('click', changeEmail);
            document.getElementById('changePasswordButton').addEventListener('click', changePassword);

            document.getElementById('rouletteBetType').addEventListener('change', () => {
                rouletteBetType = document.getElementById('rouletteBetType').value;
            });
            document.getElementById('coinHeads').addEventListener('click', () => {
                coinflipChoice = 'heads';
                document.getElementById('coinHeads').classList.add('selected');
                document.getElementById('coinTails').classList.remove('selected');
            });
            document.getElementById('coinTails').addEventListener('click', () => {
                coinflipChoice = 'tails';
                document.getElementById('coinTails').classList.add('selected');
                document.getElementById('coinHeads').classList.remove('selected');
            });
        });

        function showLoginModal() {
            document.getElementById('modal').classList.remove('hidden');
            document.getElementById('modal').style.display = 'flex';
            document.getElementById('gameInterface').classList.add('hidden');
        }

        function showGameInterface() {
            document.getElementById('modal').classList.add('hidden');
            document.getElementById('modal').style.display = 'none';
            document.getElementById('gameInterface').classList.remove('hidden');
        }

        function toggleModalForm(form) {
            document.getElementById('loginForm').classList.toggle('hidden', form !== 'login');
            document.getElementById('signupForm').classList.toggle('hidden', form !== 'signup');
            document.getElementById('loginTab').classList.toggle('active', form === 'login');
            document.getElementById('signupTab').classList.toggle('active', form === 'signup');
        }

        function login() {
            const username = document.getElementById('loginUsername').value.trim(),
                password = document.getElementById('loginPassword').value,
                errorElement = document.getElementById('loginError');
            if (!username || !password) {
                errorElement.textContent = 'Please enter username and password';
                errorElement.classList.remove('hidden');
                return;
            }
            let users = JSON.parse(localStorage.getItem('users') || '[]');
            const user = users.find(u => u && u.username === username && u.password === password);
            if (!user) {
                errorElement.textContent = 'Invalid username or password';
                errorElement.classList.remove('hidden');
                return;
            }
            currentUser = user;
            localStorage.setItem('sessionToken', generateSeed());
            localStorage.setItem('currentUsername', username);
            errorElement.classList.add('hidden');
            balance.BTC = parseFloat(localStorage.getItem(`balance_${username}_BTC`)) || 0.01;
            balance.USD = parseFloat(localStorage.getItem(`balance_${username}_USD`)) || 200;
            balance.BGT = parseFloat(localStorage.getItem(`balance_${username}_BGT`)) || 0;
            crashClientSeed = localStorage.getItem(`crashClientSeed_${username}`) || '';
            coinflipClientSeed = localStorage.getItem(`coinflipClientSeed_${username}`) || '';
            rouletteClientSeed = localStorage.getItem(`rouletteClientSeed_${username}`) || '';
            threeCardPokerClientSeed = localStorage.getItem(`threeCardPokerClientSeed_${username}`) || '';
            crashSeedTimestamp = parseInt(localStorage.getItem(`crashSeedTimestamp_${username}`) || 0);
            coinflipSeedTimestamp = parseInt(localStorage.getItem(`coinflipSeedTimestamp_${username}`) || 0);
            rouletteSeedTimestamp = parseInt(localStorage.getItem(`rouletteSeedTimestamp_${username}`) || 0);
            threeCardPokerSeedTimestamp = parseInt(localStorage.getItem(`threeCardPokerSeedTimestamp_${username}`) || 0);
            const now = Date.now();
            if (!crashClientSeed || now - crashSeedTimestamp > 3600000) {
                crashClientSeed = generateSeed();
                crashSeedTimestamp = now;
                localStorage.setItem(`crashClientSeed_${username}`, crashClientSeed);
                localStorage.setItem(`crashSeedTimestamp_${username}`, crashSeedTimestamp.toString());
            }
            if (!coinflipClientSeed || now - coinflipSeedTimestamp > 3600000) {
                coinflipClientSeed = generateSeed();
                coinflipSeedTimestamp = now;
                localStorage.setItem(`coinflipClientSeed_${username}`, coinflipClientSeed);
                localStorage.setItem(`coinflipSeedTimestamp_${username}`, coinflipSeedTimestamp.toString());
            }
            if (!rouletteClientSeed || now - rouletteSeedTimestamp > 3600000) {
                rouletteClientSeed = generateSeed();
                rouletteSeedTimestamp = now;
                localStorage.setItem(`rouletteClientSeed_${username}`, rouletteClientSeed);
                localStorage.setItem(`rouletteSeedTimestamp_${username}`, rouletteSeedTimestamp.toString());
            }
            if (!threeCardPokerClientSeed || now - threeCardPokerSeedTimestamp > 3600000) {
                threeCardPokerClientSeed = generateSeed();
                threeCardPokerSeedTimestamp = now;
                localStorage.setItem(`threeCardPokerClientSeed_${username}`, threeCardPokerClientSeed);
                localStorage.setItem(`threeCardPokerSeedTimestamp_${username}`, threeCardPokerSeedTimestamp.toString());
            }
            betHistory = JSON.parse(localStorage.getItem(`betHistory_${username}`) || '[]');
            if (!Array.isArray(betHistory)) betHistory = [];
            crashRoundLog = JSON.parse(localStorage.getItem('crashRoundLog') || '[]');
            if (!Array.isArray(crashRoundLog)) crashRoundLog = [];
            totalRounds = parseInt(localStorage.getItem('totalRounds')) || 0;
            updateBalance();
            updateUsername();
            updateHistory();
            updateRecentBetHistory();
            showGameInterface();
            startCountdownTimer();
        }

        function signup() {
            const username = document.getElementById('signupUsername').value.trim(),
                email = document.getElementById('signupEmail').value.trim(),
                password = document.getElementById('signupPassword').value,
                confirmPassword = document.getElementById('signupConfirmPassword').value,
                errorElement = document.getElementById('signupError');
            if (!username || !email || !password || !confirmPassword) {
                errorElement.textContent = 'All fields are required';
                errorElement.classList.remove('hidden');
                return;
            }
            if (!email.includes('@')) {
                errorElement.textContent = 'Invalid email address';
                errorElement.classList.remove('hidden');
                return;
            }
            if (password !== confirmPassword) {
                errorElement.textContent = 'Passwords do not match';
                errorElement.classList.remove('hidden');
                return;
            }
            let users = JSON.parse(localStorage.getItem('users') || '[]');
            if (users.find(u => u.username === username)) {
                errorElement.textContent = 'Username already taken';
                errorElement.classList.remove('hidden');
                return;
            }
            users.push({ username, email, password, role: 'user' });
            localStorage.setItem('users', JSON.stringify(users));
            errorElement.textContent = 'Sign up successful! Please log in.';
            errorElement.classList.remove('hidden');
            toggleModalForm('login');
            document.getElementById('loginUsername').value = username;
        }

        function logout() {
            if (crashInterval) clearInterval(crashInterval);
            if (countdownTimer) clearInterval(countdownTimer);
            crashGameState = 'waiting';
            localStorage.removeItem('sessionToken');
            localStorage.removeItem('currentUsername');
            if (currentUser) {
                localStorage.setItem(`balance_${currentUser.username}_BTC`, balance.BTC.toString());
                localStorage.setItem(`balance_${currentUser.username}_USD`, balance.USD.toString());
                localStorage.setItem(`balance_${currentUser.username}_BGT`, balance.BGT.toString());
                localStorage.setItem(`crashClientSeed_${currentUser.username}`, crashClientSeed);
                localStorage.setItem(`coinflipClientSeed_${currentUser.username}`, coinflipClientSeed);
                localStorage.setItem(`rouletteClientSeed_${currentUser.username}`, rouletteClientSeed);
                localStorage.setItem(`threeCardPokerClientSeed_${currentUser.username}`, threeCardPokerClientSeed);
                localStorage.setItem(`crashSeedTimestamp_${currentUser.username}`, crashSeedTimestamp.toString());
                localStorage.setItem(`coinflipSeedTimestamp_${currentUser.username}`, coinflipSeedTimestamp.toString());
                localStorage.setItem(`rouletteSeedTimestamp_${currentUser.username}`, rouletteSeedTimestamp.toString());
                localStorage.setItem(`threeCardPokerSeedTimestamp_${currentUser.username}`, threeCardPokerSeedTimestamp.toString());
                localStorage.setItem(`betHistory_${currentUser.username}`, JSON.stringify(betHistory));
                localStorage.setItem('crashRoundLog', JSON.stringify(crashRoundLog));
                localStorage.setItem('totalRounds', totalRounds.toString());
            }
            currentUser = null;
            balance = { BTC: 0.01, USD: 0, BGT: 0 };
            betHistory = [];
            crashRoundLog = [];
            totalRounds = 0;
            crashClientSeed = '';
            coinflipClientSeed = '';
            rouletteClientSeed = '';
            threeCardPokerClientSeed = '';
            crashSeedTimestamp = 0;
            coinflipSeedTimestamp = 0;
            rouletteSeedTimestamp = 0;
            threeCardPokerSeedTimestamp = 0;
            currentMultiplier = 1.00;
            crashBetAmount = 0;
            coinflipBetAmount = 0;
            rouletteBetAmount = 0;
            threeCardPokerAnteBet = 0;
            threeCardPokerPlayBet = 0;
            coinflipChoice = null;
            rouletteBetType = 'red';
            threeCardPokerState = 'waiting';
            playerHand = [];
            dealerHand = [];
            showLoginModal();
            updateCrashUI();
            alert('Logged out successfully!');
        }

        function updateBalance() {
            document.getElementById('balance').textContent = balance[currentCurrency].toFixed(4);
            document.getElementById('settingsBalance').textContent = balance[currentCurrency].toFixed(4);
            document.getElementById('currencyDisplay').textContent = currentCurrency;
            document.getElementById('settingsCurrencyDisplay').textContent = currentCurrency;
            document.getElementById('crashBetAmount').placeholder = `Bet Amount (${currentCurrency})`;
            document.getElementById('coinflipBetAmount').placeholder = `Bet Amount (${currentCurrency})`;
            document.getElementById('rouletteBetAmount').placeholder = `Bet Amount (${currentCurrency})`;
            document.getElementById('threeCardPokerBetAmount').placeholder = `Ante Bet (${currentCurrency})`;
            if (currentUser) {
                localStorage.setItem(`balance_${currentUser.username}_BTC`, balance.BTC.toString());
                localStorage.setItem(`balance_${currentUser.username}_USD`, balance.USD.toString());
                localStorage.setItem(`balance_${currentUser.username}_BGT`, balance.BGT.toString());
            }
        }

        function updateUsername() {
            document.getElementById('headerUsername').textContent = currentUser?.username || 'Guest';
            document.getElementById('settingsUsername').textContent = currentUser?.username || 'Guest';
        }

        function generateSeed() {
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
            let seed = '';
            for (let i = 0; i < 32; i++) seed += chars.charAt(Math.random() * chars.length);
            return seed;
        }

        function simpleHash(str) {
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                const char = str.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash;
            }
            return Math.abs(hash);
        }

        function initCrashGame() {
            updateCrashUI();
            startCountdownTimer();
        }

        function startCountdownTimer() {
            if (crashGameState !== 'waiting') return;
            let timeLeft = 9;
            const crashTimer = document.getElementById('crashTimer');
            crashTimer.textContent = `Next round in ${timeLeft}s`;
            if (countdownTimer) clearInterval(countdownTimer);
            countdownTimer = setInterval(() => {
                timeLeft--;
                if (timeLeft <= 0) {
                    clearInterval(countdownTimer);
                    crashTimer.textContent = 'Round in progress';
                    startCrashGame();
                } else {
                    crashTimer.textContent = `Next round in ${timeLeft}s`;
                }
            }, 1000);
        }

        function resetCrashGame() {
            currentMultiplier = 1.00;
            crashPoint = 0;
            if (crashInterval) clearInterval(crashInterval);
            crashInterval = null;
            document.getElementById('multiplier').textContent = '1.00x';
            document.getElementById('multiplier').style.backgroundColor = '#FFC107';
            document.getElementById('graphLine').style.width = '0%';
            document.getElementById('graphCrash').style.width = '0%';
            updateCrashUI();
        }

        function updateCrashUI() {
            const placeBetButton = document.getElementById('placeBetButton'),
                cancelBetButton = document.getElementById('cancelBetButton'),
                cashoutButton = document.getElementById('cashoutButton');
            if (crashGameState === 'waiting') {
                placeBetButton.disabled = false;
                cancelBetButton.disabled = true;
                cashoutButton.disabled = true;
            } else if (crashGameState === 'betting') {
                placeBetButton.disabled = true;
                cancelBetButton.disabled = false;
                cashoutButton.disabled = true;
            } else if (crashGameState === 'running') {
                placeBetButton.disabled = true;
                cancelBetButton.disabled = true;
                cashoutButton.disabled = crashBetAmount <= 0;
            } else {
                placeBetButton.disabled = true;
                cancelBetButton.disabled = true;
                cashoutButton.disabled = true;
            }
        }

        function placeCrashBet() {
            if (crashGameState !== 'waiting') {
                alert('Cannot place bet at this time. Please wait for the next round.');
                return;
            }
            crashBetAmount = parseFloat(document.getElementById('crashBetAmount').value) || 0.0001;
            if (crashBetAmount <= 0 || crashBetAmount > balance[currentCurrency]) {
                alert('Invalid bet amount or insufficient balance');
                return;
            }
            balance[currentCurrency] -= crashBetAmount;
            updateBalance();
            crashGameState = 'betting';
            updateCrashUI();
            alert(`Bet of ${crashBetAmount.toFixed(8)} ${currentCurrency} placed successfully!`);
        }

        function cancelCrashBet() {
            if (crashGameState === 'betting') {
                balance[currentCurrency] += crashBetAmount;
                updateBalance();
                crashBetAmount = 0;
                crashGameState = 'waiting';
                updateCrashUI();
                alert('Bet cancelled successfully.');
            }
        }

        function startCrashGame() {
            if (crashGameState !== 'waiting' && crashGameState !== 'betting') return;
            crashGameState = 'running';
            updateCrashUI();
            currentMultiplier = 1.00;
            crashServerSeed = generateSeed();
            const combinedSeed = crashServerSeed + crashClientSeed;
            const hash = simpleHash(combinedSeed);
            const random = (hash % 10000) / 10000;
            crashPoint = Math.max(1, Math.floor(100 / (1 - random)) / 100);
            if (random > 0.52) crashPoint = Math.max(2, crashPoint);
            crashPoint = parseFloat(crashPoint.toFixed(2));
            const multiplierElement = document.getElementById('multiplier'),
                graphLine = document.getElementById('graphLine'),
                graphCrash = document.getElementById('graphCrash');
            multiplierElement.style.backgroundColor = '#FFC107';
            graphLine.style.width = '0%';
            graphCrash.style.width = '0%';
            crashInterval = setInterval(() => {
                currentMultiplier = parseFloat((currentMultiplier + 0.01 * (1 + currentMultiplier / 10)).toFixed(2));
                multiplierElement.textContent = currentMultiplier.toFixed(2) + 'x';
                multiplierElement.style.backgroundColor = currentMultiplier >= 2 ? '#00FF00' : '#FF0000';
                const progress = (currentMultiplier / crashPoint) * 100;
                graphLine.style.width = `${Math.min(progress, 100)}%`;
                graphCrash.style.width = progress >= 100 ? '100%' : '0%';
                if (currentMultiplier >= crashPoint) endCrashGame();
            }, 100);
        }

        function endCrashGame() {
            clearInterval(crashInterval);
            crashInterval = null;
            crashGameState = 'ended';
            const timestamp = new Date().toLocaleString();
            totalRounds++;
            localStorage.setItem('totalRounds', totalRounds.toString());
            crashRoundLog.unshift({
                crashPoint: crashPoint.toFixed(2) + 'x',
                serverSeed: crashServerSeed,
                clientSeed: crashClientSeed,
                timestamp: timestamp,
                roundNumber: totalRounds,
                betAmount: crashBetAmount
            });
            if (crashRoundLog.length > 100) crashRoundLog.pop();
            localStorage.setItem('crashRoundLog', JSON.stringify(crashRoundLog));
            if (crashBetAmount > 0) {
                addToHistory('Crash', crashBetAmount, 'Loss', crashPoint);
                alert('Crashed at ' + crashPoint.toFixed(2) + 'x!');
            }
            crashBetAmount = 0;
            crashGameState = 'waiting';
            updateCrashUI();
            updateHistory();
            updateRecentBetHistory();
            startCountdownTimer();
        }

        function cashOut() {
            if (crashGameState !== 'running' || crashBetAmount <= 0) {
                alert('No active bet to cash out');
                return;
            }
            clearInterval(crashInterval);
            crashInterval = null;
            crashGameState = 'ended';
            const winnings = crashBetAmount * currentMultiplier;
            balance[currentCurrency] += winnings;
            updateBalance();
            totalRounds++;
            localStorage.setItem('totalRounds', totalRounds.toString());
            crashRoundLog.unshift({
                crashPoint: currentMultiplier.toFixed(2) + 'x',
                serverSeed: crashServerSeed,
                clientSeed: crashClientSeed,
                timestamp: new Date().toLocaleString(),
                roundNumber: totalRounds,
                betAmount: crashBetAmount
            });
            if (crashRoundLog.length > 100) crashRoundLog.pop();
            localStorage.setItem('crashRoundLog', JSON.stringify(crashRoundLog));
            addToHistory('Crash', crashBetAmount, 'Win', currentMultiplier);
            alert('Cashed out at ' + currentMultiplier.toFixed(2) + 'x! Winnings: ' + winnings.toFixed(8) + ' ' + currentCurrency);
            crashBetAmount = 0;
            crashGameState = 'waiting';
            resetCrashGame();
            updateHistory();
            updateRecentBetHistory();
            startCountdownTimer();
        }

        function verifyCrashFairness(roundIndex) {
            if (roundIndex === -1 && crashGameState === 'running') {
                alert('Cannot verify fairness during an active game.');
                return;
            }
            let serverSeedToVerify = crashServerSeed, clientSeedToVerify = crashClientSeed, crashPointToVerify = crashPoint;
            if (roundIndex !== -1) {
                const crashEntry = crashRoundLog[roundIndex];
                if (!crashEntry || !crashEntry.serverSeed || !crashEntry.clientSeed) {
                    alert('No data available to verify this round.');
                    return;
                }
                serverSeedToVerify = crashEntry.serverSeed;
                clientSeedToVerify = crashEntry.clientSeed;
                crashPointToVerify = parseFloat(crashEntry.crashPoint);
            }
            if (!serverSeedToVerify || !clientSeedToVerify) {
                alert('No crash game data to verify');
                return;
            }
            const combinedSeed = serverSeedToVerify + clientSeedToVerify;
            const hash = simpleHash(combinedSeed);
            const random = (hash % 10000) / 10000;
            let calculatedCrashPoint = Math.max(1, Math.floor(100 / (1 - random)) / 100);
            if (random > 0.52) calculatedCrashPoint = Math.max(2, calculatedCrashPoint);
            calculatedCrashPoint = parseFloat(calculatedCrashPoint.toFixed(2));
            alert(`Server Seed: ${serverSeedToVerify}\nClient Seed: ${clientSeedToVerify}\nCalculated Crash Point: ${calculatedCrashPoint}x\nActual Crash Point: ${crashPointToVerify}x`);
        }

        function startCoinflip() {
            if (!coinflipChoice) {
                alert('Please select Heads or Tails');
                return;
            }
            coinflipBetAmount = parseFloat(document.getElementById('coinflipBetAmount').value);
            if (isNaN(coinflipBetAmount) || coinflipBetAmount <= 0 || coinflipBetAmount > balance[currentCurrency]) {
                alert('Invalid bet amount or insufficient balance');
                return;
            }
            balance[currentCurrency] -= coinflipBetAmount;
            updateBalance();
            document.getElementById('coinflipAnimation').style.display = 'block';
            coinflipServerSeed = generateSeed();
            const combinedSeed = coinflipServerSeed + coinflipClientSeed;
            const hash = simpleHash(combinedSeed);
            const outcome = (hash % 2) === 0 ? 'heads' : 'tails';
            setTimeout(() => {
                document.getElementById('coinflipResult').textContent = outcome.charAt(0).toUpperCase() + outcome.slice(1);
                document.getElementById('coinAnimationHeads').style.display = outcome === 'heads' ? 'block' : 'none';
                document.getElementById('coinAnimationTails').style.display = outcome === 'tails' ? 'block' : 'none';
                document.getElementById('coinflipServerSeed').textContent = coinflipServerSeed;
                document.getElementById('coinflipClientSeed').textContent = coinflipClientSeed;
                document.getElementById('coinflipVerifyDetails').style.display = 'block';
                setTimeout(() => {
                    document.getElementById('coinflipAnimation').style.display = 'none';
                    document.getElementById('coinAnimationHeads').style.display = 'block';
                    document.getElementById('coinAnimationTails').style.display = 'block';
                }, 1000);
                if (outcome === coinflipChoice) {
                    const winnings = coinflipBetAmount * 2;
                    balance[currentCurrency] += winnings;
                    addToHistory('Coinflip', coinflipBetAmount, 'Win (' + outcome + ')', 2);
                    alert('Coinflip won! Result: ' + outcome.charAt(0).toUpperCase() + outcome.slice(1) + ', winnings: ' + winnings.toFixed(8) + ' ' + currentCurrency);
                } else {
                    addToHistory('Coinflip', coinflipBetAmount, 'Loss (' + outcome + ')', 0);
                    alert('Coinflip lost! Result: ' + outcome.charAt(0).toUpperCase() + outcome.slice(1));
                }
                updateBalance();
                updateRecentBetHistory();
                coinflipChoice = null;
                document.getElementById('coinHeads').classList.remove('selected');
                document.getElementById('coinTails').classList.remove('selected');
            }, 2000);
        }

        function verifyCoinflipFairness() {
            const coinflipResult = document.getElementById('coinflipResult').textContent;
            if (!coinflipServerSeed || !coinflipClientSeed || coinflipResult === 'Waiting for flip...') {
                alert('No coinflip data to verify');
                return;
            }
            const combinedSeed = coinflipServerSeed + coinflipClientSeed;
            const hash = simpleHash(combinedSeed);
            const calculatedOutcome = (hash % 2) === 0 ? 'heads' : 'tails';
            alert(`Server Seed: ${coinflipServerSeed}\nClient Seed: ${coinflipClientSeed}\nCalculated Outcome: ${calculatedOutcome.charAt(0).toUpperCase() + calculatedOutcome.slice(1)}\nActual Outcome: ${coinflipResult}`);
        }

        function spinRoulette() {
            rouletteBetAmount = parseFloat(document.getElementById('rouletteBetAmount').value);
            if (isNaN(rouletteBetAmount) || rouletteBetAmount <= 0 || rouletteBetAmount > balance[currentCurrency]) {
                alert('Invalid bet amount or insufficient balance');
                return;
            }
            balance[currentCurrency] -= rouletteBetAmount;
            updateBalance();
            document.getElementById('rouletteResult').textContent = 'Spinning...';
            rouletteServerSeed = generateSeed();
            const combinedSeed = rouletteServerSeed + rouletteClientSeed;
            const hash = simpleHash(combinedSeed);
            const number = hash % 37;
            let color;
            if (number === 0) {
                color = 'green';
            } else if (number <= 18) {
                color = number % 2 === 1 ? 'red' : 'black';
            } else {
                color = number % 2 === 1 ? 'black' : 'red';
            }
            setTimeout(() => {
                document.getElementById('rouletteResult').textContent = `Result: ${color.charAt(0).toUpperCase() + color.slice(1)}`;
                document.getElementById('rouletteServerSeed').textContent = rouletteServerSeed;
                document.getElementById('rouletteClientSeed').textContent = rouletteClientSeed;
                document.getElementById('rouletteVerifyDetails').style.display = 'block';
                let outcome = 'Loss', multiplier = 0;
                if (rouletteBetType === color) {
                    multiplier = color === 'green' ? 36 : 2;
                    outcome = `Win (${color.charAt(0).toUpperCase() + color.slice(1)})`;
                }
                if (multiplier > 0) {
                    const winnings = rouletteBetAmount * multiplier;
                    balance[currentCurrency] += winnings;
                    addToHistory('Roulette', rouletteBetAmount, outcome, multiplier);
                    alert(`Roulette won! Result: ${color.charAt(0).toUpperCase() + color.slice(1)}, winnings: ${winnings.toFixed(8)} ${currentCurrency}`);
                } else {
                    addToHistory('Roulette', rouletteBetAmount, `Loss (${color.charAt(0).toUpperCase() + color.slice(1)})`, 0);
                    alert(`Roulette lost! Result: ${color.charAt(0).toUpperCase() + color.slice(1)}`);
                }
                updateBalance();
                updateRecentBetHistory();
            }, 2000);
        }

        function verifyRouletteFairness() {
            const rouletteResult = document.getElementById('rouletteResult').textContent;
            if (!rouletteServerSeed || !rouletteClientSeed || rouletteResult === 'Waiting for spin...' || rouletteResult === 'Spinning...') {
                alert('No roulette data to verify');
                return;
            }
            const combinedSeed = rouletteServerSeed + rouletteClientSeed;
            const hash = simpleHash(combinedSeed);
            const calculatedNumber = hash % 37;
            let calculatedColor;
            if (calculatedNumber === 0) {
                calculatedColor = 'green';
            } else if (calculatedNumber <= 18) {
                calculatedColor = calculatedNumber % 2 === 1 ? 'red' : 'black';
            } else {
                calculatedColor = calculatedNumber % 2 === 1 ? 'black' : 'red';
            }
            alert(`Server Seed: ${rouletteServerSeed}\nClient Seed: ${rouletteClientSeed}\nCalculated Result: ${calculatedColor.charAt(0).toUpperCase() + calculatedColor.slice(1)}\nActual Result: ${rouletteResult}`);
        }

        function createDeck() {
            const suits = ['♠', '♥', '♦', '♣'],
                ranks = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];
            let deck = [];
            for (let suit of suits) {
                for (let rank of ranks) {
                    deck.push({ rank, suit });
                }
            }
            return deck;
        }

        function shuffleDeck(deck) {
            for (let i = deck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [deck[i], deck[j]] = [deck[j], deck[i]];
            }
            return deck;
        }

        function getRankValue(rank) {
            if (rank === 'A') return 14;
            if (rank === 'K') return 13;
            if (rank === 'Q') return 12;
            if (rank === 'J') return 11;
            return parseInt(rank);
        }

        function evaluateHand(hand) {
            const ranks = hand.map(card => card.rank).sort((a, b) => getRankValue(b) - getRankValue(a)),
                suits = hand.map(card => card.suit),
                values = ranks.map(getRankValue).sort((a, b) => b - a);

            const isFlush = suits.every(suit => suit === suits[0]);
            const isStraight = values[0] - values[2] === 2 && new Set(values).size === 3;
            const rankCounts = {};
            values.forEach(value => rankCounts[value] = (rankCounts[value] || 0) + 1);
            const rankCountValues = Object.values(rankCounts);

            if (isFlush && isStraight) return { type: 'Straight Flush', values };
            if (rankCountValues.includes(3)) return { type: 'Three of a Kind', values };
            if (isStraight) return { type: 'Straight', values };
            if (isFlush) return { type: 'Flush', values };
            if (rankCountValues.includes(2)) return { type: 'Pair', values };
            return { type: 'High Card', values };
        }

        function compareHands(playerHand, dealerHand) {
            const playerEval = evaluateHand(playerHand),
                dealerEval = evaluateHand(dealerHand),
                handTypes = ['High Card', 'Pair', 'Flush', 'Straight', 'Three of a Kind', 'Straight Flush'],
                playerRank = handTypes.indexOf(playerEval.type),
                dealerRank = handTypes.indexOf(dealerEval.type);

            if (playerRank > dealerRank) return 1;
            if (playerRank < dealerRank) return -1;
            for (let i = 0; i < playerEval.values.length; i++) {
                if (playerEval.values[i] > dealerEval.values[i]) return 1;
                if (playerEval.values[i] < dealerEval.values[i]) return -1;
            }
            return 0;
        }

        function getHandString(hand) {
            return hand.map(card => `${card.rank}${card.suit}`).join(', ');
        }

        function placeThreeCardPokerAnte() {
            threeCardPokerAnteBet = parseFloat(document.getElementById('threeCardPokerBetAmount').value);
            if (isNaN(threeCardPokerAnteBet) || threeCardPokerAnteBet <= 0 || threeCardPokerAnteBet > balance[currentCurrency]) {
                alert('Invalid bet amount or insufficient balance');
                return;
            }
            balance[currentCurrency] -= threeCardPokerAnteBet;
            updateBalance();
            threeCardPokerState = 'dealt';

            const deck = shuffleDeck(createDeck());
            playerHand = deck.slice(0, 3);
            dealerHand = deck.slice(3, 6);
            threeCardPokerServerSeed = generateSeed();

            document.getElementById('playerCards').textContent = getHandString(playerHand);
            document.getElementById('dealerCards').textContent = 'Hidden';
            document.getElementById('threeCardPokerResult').textContent = 'Choose to Play or Fold';
            document.getElementById('threeCardPokerDecision').classList.remove('hidden');
            document.getElementById('threeCardPokerAnteButton').disabled = true;
            document.getElementById('threeCardPokerVerifyButton').style.display = 'none';
            document.getElementById('threeCardPokerVerifyDetails').style.display = 'none';
        }

        function playThreeCardPoker() {
            threeCardPokerPlayBet = threeCardPokerAnteBet;
            if (threeCardPokerPlayBet > balance[currentCurrency]) {
                alert('Insufficient balance to place Play bet');
                return;
            }
            balance[currentCurrency] -= threeCardPokerPlayBet;
            updateBalance();
            resolveThreeCardPokerRound();
        }

        function foldThreeCardPoker() {
            addToHistory('3CP', threeCardPokerAnteBet, 'Fold', 0);
            alert('You folded. Ante bet lost.');
            resetThreeCardPoker();
        }

        function resolveThreeCardPokerRound() {
            threeCardPokerState = 'resolved';
            document.getElementById('dealerCards').textContent = getHandString(dealerHand);
            document.getElementById('threeCardPokerDecision').classList.add('hidden');
            document.getElementById('threeCardPokerVerifyButton').style.display = 'block';
            document.getElementById('threeCardPokerServerSeed').textContent = threeCardPokerServerSeed;
            document.getElementById('threeCardPokerClientSeed').textContent = threeCardPokerClientSeed;
            document.getElementById('threeCardPokerVerifyDetails').style.display = 'block';

            const dealerEval = evaluateHand(dealerHand),
                dealerQualifies = getRankValue(dealerHand.map(card => card.rank).sort((a, b) => getRankValue(b) - getRankValue(a))[0]) >= getRankValue('Q'),
                playerEval = evaluateHand(playerHand);

            let antePayout = 0, playPayout = 0, anteBonus = 0, outcome = '';

            if (playerEval.type === 'Straight Flush') anteBonus = 5;
            else if (playerEval.type === 'Three of a Kind') anteBonus = 4;
            else if (playerEval.type === 'Straight') anteBonus = 1;

            if (!dealerQualifies) {
                antePayout = threeCardPokerAnteBet;
                playPayout = 0;
                outcome = 'Win (Dealer does not qualify)';
            } else {
                const comparison = compareHands(playerHand, dealerHand);
                if (comparison > 0) {
                    antePayout = threeCardPokerAnteBet;
                    playPayout = threeCardPokerPlayBet;
                    outcome = 'Win (Better hand)';
                } else if (comparison < 0) {
                    antePayout = -threeCardPokerAnteBet;
                    playPayout = -threeCardPokerPlayBet;
                    outcome = 'Loss (Dealer wins)';
                } else {
                    antePayout = 0;
                    playPayout = 0;
                    outcome = 'Push (Tie)';
                }
            }

            const anteBonusAmount = threeCardPokerAnteBet * anteBonus,
                totalWinnings = antePayout + playPayout + anteBonusAmount;
            balance[currentCurrency] += threeCardPokerAnteBet + threeCardPokerPlayBet + totalWinnings;
            updateBalance();

            const multiplier = totalWinnings > 0 ? totalWinnings / (threeCardPokerAnteBet + threeCardPokerPlayBet) : 0;
            addToHistory('3CP', threeCardPokerAnteBet + threeCardPokerPlayBet, outcome + (anteBonus > 0 ? ` + Ante Bonus (${anteBonus}x)` : ''), multiplier);

            document.getElementById('threeCardPokerResult').textContent = `${outcome}${anteBonus > 0 ? ` + Ante Bonus (${anteBonus}x)` : ''}, Winnings: ${totalWinnings.toFixed(8)} ${currentCurrency}`;
            setTimeout(resetThreeCardPoker, 2000);
        }

        function resetThreeCardPoker() {
            threeCardPokerState = 'waiting';
            threeCardPokerAnteBet = 0;
            threeCardPokerPlayBet = 0;
            playerHand = [];
            dealerHand = [];
            document.getElementById('playerCards').textContent = 'Waiting...';
            document.getElementById('dealerCards').textContent = 'Hidden';
            document.getElementById('threeCardPokerResult').textContent = 'Waiting for bet...';
            document.getElementById('threeCardPokerDecision').classList.add('hidden');
            document.getElementById('threeCardPokerAnteButton').disabled = false;
            document.getElementById('threeCardPokerVerifyButton').style.display = 'none';
            document.getElementById('threeCardPokerVerifyDetails').style.display = 'none';
        }

        function verifyThreeCardPokerFairness() {
            if (!threeCardPokerServerSeed || !threeCardPokerClientSeed || threeCardPokerState !== 'resolved') {
                alert('No 3 Card Poker data to verify');
                return;
            }
            const combinedSeed = threeCardPokerServerSeed + threeCardPokerClientSeed;
            const hash = simpleHash(combinedSeed);
            alert(`Server Seed: ${threeCardPokerServerSeed}\nClient Seed: ${threeCardPokerClientSeed}\nHash: ${hash}\nPlayer Hand: ${getHandString(playerHand)}\nDealer Hand: ${getHandString(dealerHand)}`);
        }

        function addToHistory(game, bet, outcome, multiplier) {
            if (bet <= 0) return;
            const timestamp = new Date().toLocaleString(),
                multiplierValue = parseFloat(multiplier || 0).toFixed(2),
                outcomeStr = typeof outcome === 'string' ? outcome : 'Unknown',
                winnings = (outcomeStr.startsWith('Win') || outcomeStr.includes('Win')) ? (bet * parseFloat(multiplierValue)).toFixed(8) : '0.00000000';
            const entry = {
                game: game,
                bet: bet.toFixed(8) + ' ' + currentCurrency,
                outcome: outcomeStr,
                multiplier: multiplierValue + 'x',
                winnings: winnings + ' ' + currentCurrency,
                timestamp: timestamp
            };
            if (game === 'Crash') {
                entry.serverSeed = crashServerSeed;
                entry.clientSeed = crashClientSeed;
            } else if (game === 'Coinflip') {
                entry.serverSeed = coinflipServerSeed;
                entry.clientSeed = coinflipClientSeed;
            } else if (game === 'Roulette') {
                entry.serverSeed = rouletteServerSeed;
                entry.clientSeed = rouletteClientSeed;
            } else if (game === '3CP') {
                entry.serverSeed = threeCardPokerServerSeed;
                entry.clientSeed = threeCardPokerClientSeed;
            }
            betHistory.unshift(entry);
            if (currentUser) localStorage.setItem(`betHistory_${currentUser.username}`, JSON.stringify(betHistory));
            updateHistory();
            updateRecentBetHistory();
        }

        function updateHistory() {
            const crashRoundHistoryTable = document.getElementById('crashRoundHistoryTable'),
                settingsHistoryTable = document.getElementById('settingsHistoryTable');
            crashRoundHistoryTable.innerHTML = '<tr><th>Crash Point</th><th>Round #</th><th>Bet</th><th>Verify</th><th>Time</th></tr>';
            const recentRounds = crashRoundLog.slice(0, 10);
            recentRounds.forEach((entry, index) => {
                const hasBet = entry.betAmount && entry.betAmount > 0,
                    betDisplay = hasBet ? `${entry.betAmount.toFixed(8)} ${currentCurrency}` : 'No Bet',
                    betClass = hasBet ? 'bet' : 'no-bet',
                    crashValue = entry.crashPoint ? parseFloat(entry.crashPoint) : 0,
                    crashClass = crashValue < 1.99 ? 'crash-low' : 'crash-high';
                crashRoundHistoryTable.innerHTML += `
                    <tr>
                        <td class="${crashClass}">${entry.crashPoint || 'N/A'}</td>
                        <td>${entry.roundNumber || 'N/A'}</td>
                        <td class="${betClass}">${betDisplay}</td>
                        <td><button onclick="verifyCrashFairness(${index})">Verify</button></td>
                        <td>${entry.timestamp || 'N/A'}</td>
                    </tr>
                `;
            });
            settingsHistoryTable.innerHTML = '<tr><th>Game</th><th>Bet</th><th>Outcome</th><th>Multiplier</th><th>Winnings</th><th>Timestamp</th></tr>';
            const recentBets = betHistory.slice(0, 10);
            recentBets.forEach(entry => {
                const outcomeStr = typeof entry.outcome === 'string' ? entry.outcome : 'Unknown';
                settingsHistoryTable.innerHTML += `
                    <tr>
                        <td>${entry.game}</td>
                        <td>${entry.bet}</td>
                        <td class="${(outcomeStr.startsWith('Win') || outcomeStr.includes('Win')) ? 'win' : 'loss'}">${outcomeStr}</td>
                        <td>${entry.multiplier}</td>
                        <td>${entry.winnings}</td>
                        <td>${entry.timestamp}</td>
                    </tr>
                `;
            });
        }

        function updateRecentBetHistory() {
            const recentBetHistoryTable = document.getElementById('recentBetHistoryTable');
            recentBetHistoryTable.innerHTML = '<tr><th>Game</th><th>Bet</th><th>Outcome</th><th>Timestamp</th></tr>';
            const recentBets = betHistory.slice(0, 10);
            recentBets.forEach(entry => {
                const outcomeStr = typeof entry.outcome === 'string' ? entry.outcome : 'Unknown';
                recentBetHistoryTable.innerHTML += `
                    <tr>
                        <td>${entry.game}</td>
                        <td>${entry.bet}</td>
                        <td class="${(outcomeStr.startsWith('Win') || outcomeStr.includes('Win')) ? 'win' : 'loss'}">${outcomeStr}</td>
                        <td>${entry.timestamp}</td>
                    </tr>
                `;
            });
        }

        function showSection(section) {
            ['crashSection', 'coinflipSection', 'rouletteSection', 'threeCardPokerSection', 'accountSection'].forEach(id => {
                document.getElementById(id).classList.add('hidden');
            });
            ['tabCrash', 'tabCoinflip', 'tabRoulette', 'tab3CP', 'tabAccount'].forEach(id => {
                document.getElementById(id).classList.remove('active');
            });
            const sectionElement = document.getElementById(`${section === '3cp' ? 'threeCardPoker' : section}Section`),
                tabElement = document.getElementById(`tab${section === '3cp' ? '3CP' : section.charAt(0).toUpperCase() + section.slice(1)}`);
            sectionElement.classList.remove('hidden');
            tabElement.classList.add('active');
        }

        function showSubSection(subsection) {
            ['detailsSubSection', 'historySubSection'].forEach(id => {
                document.getElementById(id).classList.add('hidden');
            });
            document.getElementById(`${subsection}SubSection`).classList.remove('hidden');
            if (subsection === 'history') {
                updateHistory();
            }
        }

        function switchCurrency() {
            const newCurrency = document.getElementById('currencySelector').value;
            if (newCurrency === 'BGT') {
                alert('BGT mode is not yet available.');
                document.getElementById('currencySelector').value = currentCurrency;
                return;
            }
            const prevCurrency = currentCurrency;
            currentCurrency = newCurrency;
            if (prevCurrency === 'BTC' && newCurrency === 'USD') {
                balance.USD = balance.BTC * 200;
            } else if (prevCurrency === 'USD' && newCurrency === 'BTC') {
                balance.BTC = balance.USD / 200;
            }
            updateBalance();
        }

        function changeEmail() {
            const newEmail = document.getElementById('newEmail').value.trim(),
                emailMessage = document.getElementById('emailMessage'),
                currentEmailInput = document.getElementById('currentEmail');
            if (!newEmail || !newEmail.includes('@')) {
                emailMessage.textContent = 'Please enter a valid email address';
                emailMessage.classList.remove('hidden');
                return;
            }
            let users = JSON.parse(localStorage.getItem('users') || '[]');
            const userIndex = users.findIndex(u => u.username === currentUser.username);
            if (userIndex !== -1) {
                users[userIndex].email = newEmail;
                localStorage.setItem('users', JSON.stringify(users));
                currentUser.email = newEmail;
                currentEmailInput.value = newEmail;
                emailMessage.textContent = 'Email updated successfully';
                emailMessage.classList.remove('hidden');
                setTimeout(() => emailMessage.classList.add('hidden'), 3000);
            } else {
                emailMessage.textContent = 'Failed to update email';
                emailMessage.classList.remove('hidden');
            }
        }

        function changePassword() {
            const currentPassword = document.getElementById('currentPassword').value,
                newPassword = document.getElementById('newPassword').value,
                confirmNewPassword = document.getElementById('confirmNewPassword').value,
                passwordMessage = document.getElementById('passwordMessage');
            if (!currentPassword || !newPassword || !confirmNewPassword) {
                passwordMessage.textContent = 'All fields are required';
                passwordMessage.classList.remove('hidden');
                return;
            }
            if (currentPassword !== currentUser.password) {
                passwordMessage.textContent = 'Current password is incorrect';
                passwordMessage.classList.remove('hidden');
                return;
            }
            if (newPassword !== confirmNewPassword) {
                passwordMessage.textContent = 'New passwords do not match';
                passwordMessage.classList.remove('hidden');
                return;
            }
            if (newPassword.length < 8) {
                passwordMessage.textContent = 'New password must be at least 8 characters';
                passwordMessage.classList.remove('hidden');
                return;
            }
            let users = JSON.parse(localStorage.getItem('users') || '[]');
            const userIndex = users.findIndex(u => u.username === currentUser.username);
            if (userIndex !== -1) {
                users[userIndex].password = newPassword;
                localStorage.setItem('users', JSON.stringify(users));
                currentUser.password = newPassword;
                passwordMessage.textContent = 'Password updated successfully';
                passwordMessage.classList.remove('hidden');
                setTimeout(() => passwordMessage.classList.add('hidden'), 3000);
            } else {
                passwordMessage.textContent = 'Failed to update password';
                passwordMessage.classList.remove('hidden');
            }
        }
    </script>
</body>
</html>